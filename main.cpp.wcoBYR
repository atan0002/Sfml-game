#include <iostream>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>
#include <background.cpp>
#include <cmath>


sf::RenderWindow game;
 int pred=150;


























 int main() {
    // create the window
   sf::RenderWindow game(sf::VideoMode(800,500), "My window");

    sf::Texture texture;
    if(!texture.loadFromFile("ludzik.jpg")){
        std::cout<<"Load failed"<<std::endl;
        system("pause");
    }
    sf::Sprite gracz;
    gracz.setTexture(texture);
    gracz.setPosition(3,350);
    sf::View            View;
            //(game.getDefaultView());
        sf::FloatRect       fBounds(0.f, 0.f, 1800.f, 1000.f); // arbitrary > view height
        sf::FloatRect       fBounds2(0.f, 0.f, 1800.f, 1000.f); // arbitrary > view "SIZE"


            // move sprite 'up' by its height except the view height for start:




         sf::Texture text;


          sf::IntRect         iBounds(fBounds);
         text.setRepeated(true);
         if(!text.loadFromFile("background_2.jpg")){
             std::cout<<"Load failed"<<std::endl;
             system("pause");
         }

         sf::Sprite sp(text,iBounds);



           sp.setPosition(fBounds.left, fBounds.top - 1000.f + View.getSize().y);
        // sf::View view(sf::FloatRect(200,200,300,200));



         const sf::Vector2f viewStart(fBounds.left + (fBounds.width / 2), fBounds.top + (fBounds.height / 2));

                 const sf::Vector2f spriteStart(fBounds.left, fBounds.top);




        View.setViewport(sf::FloatRect(0.f,0.f,1.9f, 1.7f));















    // create some shapes


    sf::Clock clock;
    // run the program as long as the window is open
    while (game.isOpen()) {
        // check all the window's events that were triggered since the last iteration of the loop
        sf::Event event;

        while (game.pollEvent(event)) {


            // "close requested" event: we close the window
            if (event.type == sf::Event::Closed)
                game.close();
            if((event.type == sf::Event::KeyPressed) && (event.key.code == sf::Keyboard::Right))
                       {
                         View.move(+5, 0);
                         gracz.move(+5,0);
                          }
           if((event.type == sf::Event::KeyPressed) && (event.key.code == sf::Keyboard::Left))
                 {
                        View.move(-5, 0);
                        gracz.move(-5,0);
                     }
           if((event.type == sf::Event::KeyPressed) && (event.key.code == sf::Keyboard::Up))
                      {
                        gracz.move(0, -7);
                     }
        }



 // sf::Time elapsed=clock.restart();
//float time= elapsed.asSeconds();
        // clear the window with black color

sf::FloatRect gracz_bounds = gracz.getGlobalBounds();
//sf::FloatRect view_bounds = sp.getGlobalBounds();
game.clear(sf::Color::Black);
//gracz.move(time*pred,0);
             const sf::Vector2f viewOffset(viewStart - View.getCenter());
              sf::Vector2f spriteOffset;
              sf::Vector2f spriteOffset2;
                spriteOffset.x = floor(viewOffset.x / text.getSize().x) * text.getSize().x+722;
                // spriteOffset2.x = floor(viewOffset.x / text2.getSize().x) * text2.getSize().x+722;
                    spriteOffset.y = floor(viewOffset.y / text.getSize().y) * text.getSize().y;
                   sp.setPosition(spriteStart - spriteOffset);

                   game.clear();
               game.setView(View);
              game.draw(sp);
             game.draw(gracz);























        if(gracz_bounds.left<0){
            pred=std::abs(pred);

        }
        /*if(gracz_bounds.left+gracz_bounds.width>799){
        pred=-std::abs(pred);

        }*/

       game.display();
    }

    return 0;
}


